# aspz-lab4
ТВ-31 Троцюк Андрій

Варіант 17

Завдання 4.1

Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

Результат: 

![image](https://github.com/user-attachments/assets/2147f509-7e78-4d05-9578-ecefc3311f78)

Запуск на 64-бітній системі

![image](https://github.com/user-attachments/assets/7e47d562-d367-413e-8f94-19fe56998687)

Запуск на 32-бітній системі

![image](https://github.com/user-attachments/assets/139a878a-9b11-4130-9348-f4c5cf579bba)

Теоретично максимальний обсяг пам'яті для malloc на 64-бітній системі — 16 ексабайт (2^64 байт). Однак на практиці це обмежено 8 ексабайтами, оскільки для адресації пам'яті використовуються лише 57 бітів із 64, через обмеження архітектури процесора та операційної системи.

Завдання 4.2

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

Результат: 

![image](https://github.com/user-attachments/assets/8ae1c0b3-c7a5-4f6f-b773-d3dfc2def7a8)
![image](https://github.com/user-attachments/assets/aaa7cb70-1a92-47e9-9714-a1df1ad19d5d)
![image](https://github.com/user-attachments/assets/9dbb8a6c-dc04-454b-834f-d193a965dd4e)


Якщо передати від’ємний аргумент у malloc(3), це може призвести до непередбачуваних результатів, оскільки malloc очікує беззнакове значення для розміру пам'яті. Коли передається від’ємне число, воно перетворюється на дуже велике позитивне число через переповнення при конвертації знакових чисел у беззнакові. Наприклад, якщо ми обчислюємо кількість пам'яті за формулою num = xa * xb, де xa = -10000 і xb = 10000, результат множення призведе до переповнення, і num стане дуже великим позитивним числом. При передачі цього значення в malloc, функція намагатиметься виділити величезну кількість пам'яті, що неможливо, і вона поверне NULL, що вказує на помилку виділення пам'яті. Ця поведінка буде однаковою на архітектурах x86_64 і x86, де в обох випадках програма виведе повідомлення "malloc failed: Cannot allocate memory" через неможливість виділити таку кількість пам'яті.


Завдання 4.3

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.


Результат: 

![image](https://github.com/user-attachments/assets/19d40014-535d-4fa4-bcab-5bd3ce87cd2d)
![image](https://github.com/user-attachments/assets/67cc7028-0485-41e5-bb7a-8051375ec84d)


Якщо викликати malloc(0), поведінка залежить від реалізації бібліотеки. У моєму випадку malloc(0) повернув непорожній вказівник (0x55713f92c2a0), який можна було безпечно передати у free(). Це підтверджується виводом ltrace: було викликано malloc(0), потім free(вказівник), і програма завершилась без помилок. Таким чином, навіть якщо пам’ять не виділяється фактично, malloc може повертати валідний вказівник, який можна звільнити через free().


Завдання 4.4

Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.


Результат: 

![image](https://github.com/user-attachments/assets/8cf67e0c-a21f-47e0-802a-a6bf1f0f92f9)
![image](https://github.com/user-attachments/assets/eae28732-79a2-4e2b-8fb9-78d2733a6eab)


У початковому коді була логічна помилка: пам’ять виділяється лише один раз (коли ptr == NULL), але звільняється на кожній ітерації циклу. Це призводить до використання звільненої пам’яті (use-after-free) на наступних ітераціях, оскільки ptr не оновлюється після free(ptr) — він лишається вказівником на вже вільну область.У моєму варіанті пам’ять виділяється на кожній ітерації та одразу звільняється. Перевірка через valgrind підтвердила, що в програмі немає помилок або витоків пам’яті.


Завдання 4.5

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.


Результат: 

![image](https://github.com/user-attachments/assets/34ca44b5-3a11-4688-931d-c3224623f391)
![image](https://github.com/user-attachments/assets/f8d2cbe4-f650-41aa-970b-d7a79b4d9288)


Якщо realloc(3) не може виділити пам’ять, вона повертає NULL, але старий блок пам’яті залишається дійсним і не звільняється. Якщо одразу присвоїти результат realloc() у той самий вказівник без перевірки, можна втратити доступ до старого блоку, що призведе до витоку пам’яті. У тесті ми спочатку виділили невеликий блок, а потім намагалися розширити його до дуже великого розміру. realloc() повернула NULL, і ми звільнили старий блок вручну, що демонструє правильну обробку помилки.


Завдання 4.6

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.


Результат: 

![image](https://github.com/user-attachments/assets/2cc9a91a-ed24-4a77-a1f4-1c3206313307)
![image](https://github.com/user-attachments/assets/564888e6-364e-4ff2-b701-3305edfb3524)

Якщо realloc() викликається з NULL, вона працює як malloc() і виділяє нову пам’ять. Якщо передати розмір 0, realloc() звільняє пам’ять і за стандартом може повернути NULL або вказівник, який також потрібно буде звільнити. У тесті перший випадок повернув дійсний вказівник, другий — NULL, що означає, що пам’ять була звільнена.

Завдання 4.7

Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.



Результат: 

Перша версія:

![image](https://github.com/user-attachments/assets/65e3fb95-d77b-4fb5-ae41-5b41ef7b75a7)

Друга версія:

![image](https://github.com/user-attachments/assets/e32cf30a-e9c7-49ad-bc76-77994fc24c80)

Результат роботи першої:

![image](https://github.com/user-attachments/assets/0e9ca448-3517-45e0-b0e8-904a37a84596)

Результат роботи другої:

![image](https://github.com/user-attachments/assets/fc6d209a-bbe9-4a50-ab72-dfe75668dd11)


Обидві версії працюють однаково в нормальних умовах, що видно через ltrace, але reallocarray() додатково перевіряє переповнення під час обчислення розміру. Це робить її безпечнішою у випадках, коли множення count * size може вийти за межі типу size_t.


Завдання 4.17(індивідуальне)

Напишіть тестовий випадок, що досліджує різницю між виділенням великої та малої кількості пам’яті.


Результат: 

![image](https://github.com/user-attachments/assets/516711c1-9c26-43e7-a7db-f43ad2e958a4)
![image](https://github.com/user-attachments/assets/fc3aadf1-05c5-428c-947c-78e95b2d6e31)

Виділення малої пам’яті (1 KB) проходить успішно, а спроба виділити великий блок (10 GB) завершується невдачею. Це демонструє обмеження системи на великі алокації, які залежать від доступної пам’яті та налаштувань ОС.

Висновок

Під час виконання лабораторної роботи я розібрався, як працює динамічне виділення памʼяті в C за допомогою функцій malloc, calloc, realloc, reallocarray та free. Я перевірив, як ці функції поводяться в різних ситуаціях — при нульовому розмірі, переповненні, великих об'ємах памʼяті або відʼємних значеннях. Особливо звернув увагу на помилки, які можуть виникнути, наприклад, use-after-free або втрата доступу до памʼяті при неправильному використанні realloc. Також навчився перевіряти правильність роботи програм за допомогою valgrind і ltrace. Загалом, ця лабораторна допомогла краще зрозуміти, як безпечно працювати з памʼяттю в C.
