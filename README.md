# aspz-lab4
Завдання 4.1
Результат: Розраховано та перевірено межі size_t, експериментально перевірено на x86 та x86_64.

Завдання 4.2
Результат: malloc повертає NULL. Проаналізовано причину — тип int переповнюється до відʼємного значення.

Завдання 4.3
Результат: malloc може повернути як NULL, так і дійсний вказівник — обидва результати дозволені стандартом. free(ptr) є безпечним навіть у такому випадку.

Завдання 4.4
Результат: Виявлена логічна помилка. Виправлено: памʼять виділяється та звільняється коректно на кожній ітерації. Перевірено через valgrind.

Завдання 4.5
Результат: realloc повертає NULL, при цьому старий блок залишається дійсним — необхідно зберігати оригінальний вказівник.

Завдання 4.6
Результат: перше поводиться як malloc(size), друге — як free(ptr) з поверненням NULL.

Завдання 4.7
Результат: reallocarray перевіряє переповнення під час обчислення розміру. Через ltrace видно виклик саме цієї функції.

Завдання 4.17(індивідуальне)
Результат: 1 KB — успішно, 10 GB — помилка. Це демонструє обмеження ОС 

Висновок
Під час виконання лабораторної роботи я розібрався, як працює динамічне виділення памʼяті в C за допомогою функцій malloc, calloc, realloc, reallocarray та free. Я перевірив, як ці функції поводяться в різних ситуаціях — при нульовому розмірі, переповненні, великих об'ємах памʼяті або відʼємних значеннях. Особливо звернув увагу на помилки, які можуть виникнути, наприклад, use-after-free або втрата доступу до памʼяті при неправильному використанні realloc. Також навчився перевіряти правильність роботи програм за допомогою valgrind і ltrace. Загалом, ця лабораторна допомогла краще зрозуміти, як безпечно працювати з памʼяттю в C.
